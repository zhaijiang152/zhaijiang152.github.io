<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>12.删除链表的倒数第 N 个结点</title>
      <link href="/2026/02/27/26-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2026/02/27/26-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">int</span> length = <span class="built_in">getLength</span>(head);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length - n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">// ListNode* ans = dummy-&gt;next;</span></span><br><span class="line">        dummy=dummy-&gt;next;</span><br><span class="line">        <span class="comment">// delete dummy;</span></span><br><span class="line">        <span class="comment">// return ans;</span></span><br><span class="line">        <span class="keyword">return</span> dummy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/SLwz0R/">https://leetcode.cn/problems/SLwz0R/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11.求一个整数的平方根保留两位小数</title>
      <link href="/2026/02/14/25-%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%E4%BF%9D%E7%95%99%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0/"/>
      <url>/2026/02/14/25-%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%E4%BF%9D%E7%95%99%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> right = n;</span><br><span class="line">    <span class="type">double</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (right - left &gt; <span class="number">0.0001</span>) &#123;  <span class="comment">// 控制精度</span></span><br><span class="line">        mid = (left + right) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &lt; n)</span><br><span class="line">            left = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">double</span> ans = <span class="built_in">mySqrt</span>(n);</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.反转链表</title>
      <link href="/2026/02/14/24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2026/02/14/24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            ListNode* next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/UHnkqh/description/">https://leetcode.cn/problems/UHnkqh/description/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9.简单二分搜索插入位置</title>
      <link href="/2026/02/14/23-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>/2026/02/14/23-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, ans = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = ((right - left)/<span class="number">2</span>) + left;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/search-insert-position/?envType=problem-list-v2&envId=ErEwgxB2">https://leetcode.cn/problems/search-insert-position/?envType=problem-list-v2&amp;envId=ErEwgxB2</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8.最长递增子序列</title>
      <link href="/2026/02/14/22-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2026/02/14/22-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = (<span class="type">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">https://leetcode.cn/problems/longest-increasing-subsequence/description/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.反转二叉树</title>
      <link href="/2026/02/14/21-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2026/02/14/21-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* left = <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        TreeNode* right = <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/invert-binary-tree/">https://leetcode.cn/problems/invert-binary-tree/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.岛屿数量</title>
      <link href="/2026/02/14/20-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
      <url>/2026/02/14/20-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">            <span class="comment">// 出界，或者不是 &#x27;1&#x27;，就不再往下递归</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || grid[i][j] != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            grid[i][j] = <span class="string">&#x27;2&#x27;</span>; <span class="comment">// 插旗！避免来回横跳无限递归</span></span><br><span class="line">            <span class="built_in">dfs</span>(i, j - <span class="number">1</span>); <span class="comment">// 往左走</span></span><br><span class="line">            <span class="built_in">dfs</span>(i, j + <span class="number">1</span>); <span class="comment">// 往右走</span></span><br><span class="line">            <span class="built_in">dfs</span>(i - <span class="number">1</span>, j); <span class="comment">// 往上走</span></span><br><span class="line">            <span class="built_in">dfs</span>(i + <span class="number">1</span>, j); <span class="comment">// 往下走</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123; <span class="comment">// 找到了一个新的岛</span></span><br><span class="line">                    <span class="built_in">dfs</span>(i, j); <span class="comment">// 把这个岛插满旗子，这样后面遍历到的 &#x27;1&#x27; 一定是新的岛</span></span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/number-of-islands/">https://leetcode.cn/problems/number-of-islands/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.最大交替子序列和</title>
      <link href="/2026/02/14/19-%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%9B%BF%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"/>
      <url>/2026/02/14/19-%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%9B%BF%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxAlternatingSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> even = nums[<span class="number">0</span>], odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            even = <span class="built_in">max</span>(even, odd + nums[i]);</span><br><span class="line">            odd = <span class="built_in">max</span>(odd, even - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> even;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-alternating-subsequence-sum/">https://leetcode.cn/problems/maximum-alternating-subsequence-sum/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.三数之和</title>
      <link href="/2026/02/14/18-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2026/02/14/18-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        ranges::<span class="built_in">sort</span>(nums);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; x == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 跳过重复数字</span></span><br><span class="line">            <span class="keyword">if</span> (x + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 优化一</span></span><br><span class="line">            <span class="keyword">if</span> (x + nums[n - <span class="number">2</span>] + nums[n - <span class="number">1</span>] &lt; <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 优化二</span></span><br><span class="line">            <span class="type">int</span> j = i + <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="type">int</span> s = x + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 三数之和为 0</span></span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;x, nums[j], nums[k]&#125;);</span><br><span class="line">                    <span class="keyword">for</span> (j++; j &lt; k &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]; j++); <span class="comment">// 跳过重复数字</span></span><br><span class="line">                    <span class="keyword">for</span> (k--; k &gt; j &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]; k--); <span class="comment">// 跳过重复数字</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/3sum/description/">https://leetcode.cn/problems/3sum/description/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.二叉树的右视图</title>
      <link href="/2026/02/14/17-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
      <url>/2026/02/14/17-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size=q.<span class="built_in">size</span>();</span><br><span class="line">            TreeNode*lastnode=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;</span><br><span class="line">            TreeNode*node=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            lastnode=node;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(lastnode-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">https://leetcode.cn/problems/binary-tree-right-side-view/description/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.无重复字符的最长子串</title>
      <link href="/2026/02/14/16-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2026/02/14/16-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt=s.<span class="built_in">size</span>(),sum=<span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(s[i]))&#123;</span><br><span class="line">                sum++;</span><br><span class="line">                mp[s[i]]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum==cnt)<span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=sum;i&gt;=<span class="number">3</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=cnt-i;j++)&#123;<span class="comment">//j是当前初始查找位置</span></span><br><span class="line">            map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;mp2;</span><br><span class="line">            <span class="type">int</span> y=j,sum2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> z=<span class="number">1</span>;z&lt;=i;z++)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(!mp<span class="number">2.</span><span class="built_in">count</span>(s[y]))&#123;</span><br><span class="line">                sum2++;</span><br><span class="line">                mp2[s[y]]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            y++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum2==i)<span class="keyword">return</span> sum2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.手撕快排</title>
      <link href="/2026/02/14/15-%E6%89%8B%E6%92%95%E5%BF%AB%E6%8E%92/"/>
      <url>/2026/02/14/15-%E6%89%8B%E6%92%95%E5%BF%AB%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = left + <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> pivot = nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[left]);</span><br><span class="line"></span><br><span class="line">        i = left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = right;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[i] &lt; pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[j] &gt; pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[left], nums[j]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速排序子数组 [left, right]</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">bool</span> ordered = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                ordered = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">partition</span>(nums, left, right); </span><br><span class="line">        <span class="built_in">quick_sort</span>(nums, left, i - <span class="number">1</span>);  </span><br><span class="line">        <span class="built_in">quick_sort</span>(nums, i + <span class="number">1</span>, right); </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quick_sort</span>(nums, <span class="number">0</span>, (<span class="type">int</span>) nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sort-an-array/description/">https://leetcode.cn/problems/sort-an-array/description/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简易筛质数</title>
      <link href="/2025/12/23/14-%E7%AE%80%E6%98%93%E7%AD%9B%E8%B4%A8%E6%95%B0/"/>
      <url>/2025/12/23/14-%E7%AE%80%E6%98%93%E7%AD%9B%E8%B4%A8%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、int-is-int-n-的作用是什么？"><a href="#一、int-is-int-n-的作用是什么？" class="headerlink" title="一、int is(int n) 的作用是什么？"></a>一、<code>int is(int n)</code> 的作用是什么？</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">is</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 <strong>作用：判断一个整数 <code>n</code> 是否是质数（素数）</strong></p><ul><li>返回 <code>1</code>：<code>n</code> 是质数</li><li>返回 <code>0</code>：<code>n</code> 不是质数</li></ul><p>所以它本质上是一个 <strong>质数判定函数</strong>。</p><hr><h2 id="二、为什么这样写能判断质数？"><a href="#二、为什么这样写能判断质数？" class="headerlink" title="二、为什么这样写能判断质数？"></a>二、为什么这样写能判断质数？</h2><h3 id="1️⃣-质数的定义"><a href="#1️⃣-质数的定义" class="headerlink" title="1️⃣ 质数的定义"></a>1️⃣ 质数的定义</h3><blockquote><p><strong>质数</strong>：只能被 <code>1</code> 和自身整除的正整数（<code>n ≥ 2</code>）</p></blockquote><hr><h3 id="2️⃣-为什么从-i-2-开始？"><a href="#2️⃣-为什么从-i-2-开始？" class="headerlink" title="2️⃣ 为什么从 i = 2 开始？"></a>2️⃣ 为什么从 <code>i = 2</code> 开始？</h3><ul><li><code>1</code> 肯定能整除任何数，没意义</li><li>所以从 <strong>最小可能的因子 <code>2</code></strong> 开始试</li></ul><hr><h3 id="3️⃣-为什么只枚举到-i-i"><a href="#3️⃣-为什么只枚举到-i-i" class="headerlink" title="3️⃣ 为什么只枚举到 i * i &lt;= n？"></a>3️⃣ 为什么只枚举到 <code>i * i &lt;= n</code>？</h3><p>这是关键点 👇</p><h4 id="数学原理："><a href="#数学原理：" class="headerlink" title="数学原理："></a>数学原理：</h4><p>如果 <code>n</code> 是合数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = a × b</span><br></pre></td></tr></table></figure><p>那么：</p><ul><li>至少有一个因子 <strong>≤ √n</strong></li><li>如果两个因子都 &gt; √n，那么乘积会 &gt; n（矛盾）</li></ul><p>✅ 所以：</p><blockquote><p><strong>只要检查到 √n，就能确定 n 是否有因子</strong></p></blockquote><p>这也是为什么不用枚举到 <code>n-1</code>，可以大幅优化速度。</p><hr><h3 id="4️⃣-if-n-i-0-return-0"><a href="#4️⃣-if-n-i-0-return-0" class="headerlink" title="4️⃣ if(n % i == 0) return 0;"></a>4️⃣ <code>if(n % i == 0) return 0;</code></h3><ul><li>找到一个能整除 <code>n</code> 的数</li><li>说明 <code>n</code> <strong>不是质数</strong></li><li>立刻返回 <code>0</code>（提前结束，节省时间）</li></ul><hr><h3 id="5️⃣-return-1"><a href="#5️⃣-return-1" class="headerlink" title="5️⃣ return 1;"></a>5️⃣ <code>return 1;</code></h3><ul><li>循环结束都没找到因子</li><li>说明 <code>n</code> <strong>是质数</strong></li></ul><hr><h2 id="三、它在-solve-里起什么作用？"><a href="#三、它在-solve-里起什么作用？" class="headerlink" title="三、它在 solve() 里起什么作用？"></a>三、它在 <code>solve()</code> 里起什么作用？</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">10000</span>;i++) </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is</span>(i)) a.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure><p>👉 这段代码的作用是：</p><ul><li><strong>筛出 2 ~ 10000 之间的所有质数</strong></li><li>存进 <code>vector&lt;int&gt; a</code></li></ul><p>后面这一步：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pow</span>(a[i],<span class="number">2</span>) + <span class="built_in">pow</span>(a[j],<span class="number">3</span>) + <span class="built_in">pow</span>(a[k],<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>说明题目要求的是：</p><blockquote><p><strong>质数² + 质数³ + 质数⁴</strong></p></blockquote><p>所以必须先把 <strong>质数集合</strong> 算出来，<code>is()</code> 就是为这个服务的。</p><hr><h2 id="四、为什么不用更简单的方法？"><a href="#四、为什么不用更简单的方法？" class="headerlink" title="四、为什么不用更简单的方法？"></a>四、为什么不用更简单的方法？</h2><p>你可能会想到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br></pre></td></tr></table></figure><p>❌ 这样是 <strong>O(n)</strong><br>现在这种写法是 <strong>O(√n)</strong>，速度快很多。</p><p>在竞赛中：</p><ul><li><code>n ≤ 10000</code></li><li>判 10000 次质数</li><li>这种写法完全没问题</li></ul><hr><h2 id="五、这个函数有没有问题？（重要）"><a href="#五、这个函数有没有问题？（重要）" class="headerlink" title="五、这个函数有没有问题？（重要）"></a>五、这个函数有没有问题？（重要）</h2><h3 id="❌-潜在-bug"><a href="#❌-潜在-bug" class="headerlink" title="❌ 潜在 bug"></a>❌ 潜在 bug</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">is</span>(<span class="number">1</span>) 会返回 <span class="number">1</span>（错误）</span><br></pre></td></tr></table></figure><p>因为循环不进，直接 <code>return 1</code></p><p>✅ 更严谨写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="六、一句话总结（你记这个就够）"><a href="#六、一句话总结（你记这个就够）" class="headerlink" title="六、一句话总结（你记这个就够）"></a>六、一句话总结（你记这个就够）</h2><blockquote><p><strong><code>is(int n)</code> 用来判断 n 是否是质数，通过枚举 2 到 √n 的因子，高效且常见，是竞赛中最基础的质数判定方法。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++算法知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何启用butterfly主题的搜索功能</title>
      <link href="/2025/12/21/13-%E5%A6%82%E4%BD%95%E5%90%AF%E7%94%A8butterfly%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
      <url>/2025/12/21/13-%E5%A6%82%E4%BD%95%E5%90%AF%E7%94%A8butterfly%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="步骤-1：配置搜索功能"><a href="#步骤-1：配置搜索功能" class="headerlink" title="步骤 1：配置搜索功能"></a>步骤 1：配置搜索功能</h3><p>从butterfly的_config.yml文件中到找search</p><p>在 <code>search</code> 设置中，选择使用本地搜索（<code>local_search</code>）或使用 Algolia 搜索（<code>algolia_search</code>）。如果你想使用本地搜索，可以按照以下步骤配置：</p><ol><li><strong>启用本地搜索</strong><br> 在 <code>search</code> 配置块下，设置 <code>use: local_search</code>，并确保 <code>local_search</code> 的配置项被正确设置。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">local_search</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">&quot;搜索文章...&quot;</span>  <span class="comment"># 你可以自定义搜索框的占位符</span></span><br><span class="line">  <span class="attr">local_search:</span></span><br><span class="line">    <span class="attr">preload:</span> <span class="literal">true</span>  <span class="comment"># 页面加载时预加载搜索数据</span></span><br><span class="line">    <span class="attr">top_n_per_article:</span> <span class="number">1</span>  <span class="comment"># 每篇文章显示前 n 个搜索结果</span></span><br><span class="line">    <span class="attr">unescape:</span> <span class="literal">false</span>  <span class="comment"># 将 HTML 字符串转义为可读形式</span></span><br><span class="line">    <span class="attr">pagination:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">false</span>  <span class="comment"># 不启用搜索结果分页</span></span><br><span class="line">      <span class="attr">hitsPerPage:</span> <span class="number">8</span>  <span class="comment"># 每页显示 8 个搜索结果</span></span><br></pre></td></tr></table></figure><ol><li><strong>如果你选择使用 Algolia 搜索</strong>，你需要配置相应的 Algolia 搜索 API 配置：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">algolia_search</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">&quot;搜索文章...&quot;</span></span><br><span class="line">  <span class="attr">algolia_search:</span></span><br><span class="line">    <span class="attr">appId:</span> <span class="string">&quot;你的 appId&quot;</span></span><br><span class="line">    <span class="attr">apiKey:</span> <span class="string">&quot;你的 apiKey&quot;</span></span><br><span class="line">    <span class="attr">indexName:</span> <span class="string">&quot;你的 indexName&quot;</span></span><br><span class="line">    <span class="attr">hitsPerPage:</span> <span class="number">6</span>  <span class="comment"># 每页显示搜索结果的数量</span></span><br></pre></td></tr></table></figure><h3 id="步骤-2：安装依赖插件"><a href="#步骤-2：安装依赖插件" class="headerlink" title="步骤 2：安装依赖插件"></a>步骤 2：安装依赖插件</h3><p>如果你使用的是 <code>local_search</code>，需要安装 <code>hexo-generator-search</code> 插件，它会生成用于搜索的索引文件。在 Hexo 项目的根目录下运行以下命令安装该插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><h3 id="步骤-3：生成并部署"><a href="#步骤-3：生成并部署" class="headerlink" title="步骤 3：生成并部署"></a>步骤 3：生成并部署</h3><p>配置完成后，执行 Hexo 的 <code>generate</code> 命令生成静态文件，并通过 <code>deploy</code> 命令将其部署到你的博客站点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>队列queue的用法</title>
      <link href="/2025/12/21/12-queue%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2025/12/21/12-queue%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、queue-是什么"><a href="#一、queue-是什么" class="headerlink" title="一、queue 是什么"></a>一、<code>queue</code> 是什么</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br></pre></td></tr></table></figure><ul><li><strong>先进先出（FIFO）</strong> 数据结构</li><li>底层用 <strong>deque</strong> 实现（也可以用 list）</li><li>常用操作：<strong>入队、出队、访问队头&#x2F;队尾</strong></li></ul><hr><h2 id="二、基本操作"><a href="#二、基本操作" class="headerlink" title="二、基本操作"></a>二、基本操作</h2><h3 id="1️⃣-入队"><a href="#1️⃣-入队" class="headerlink" title="1️⃣ 入队"></a>1️⃣ 入队</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>(<span class="number">10</span>); <span class="comment">// 队尾插入 10</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h3 id="2️⃣-出队"><a href="#2️⃣-出队" class="headerlink" title="2️⃣ 出队"></a>2️⃣ 出队</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">pop</span>(); <span class="comment">// 删除队头元素（不返回值）</span></span><br></pre></td></tr></table></figure><h3 id="3️⃣-访问队头-队尾"><a href="#3️⃣-访问队头-队尾" class="headerlink" title="3️⃣ 访问队头 &#x2F; 队尾"></a>3️⃣ 访问队头 &#x2F; 队尾</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; q.<span class="built_in">front</span>(); <span class="comment">// 队头元素</span></span><br><span class="line">cout &lt;&lt; q.<span class="built_in">back</span>();  <span class="comment">// 队尾元素</span></span><br></pre></td></tr></table></figure><h3 id="4️⃣-队列大小-是否为空"><a href="#4️⃣-队列大小-是否为空" class="headerlink" title="4️⃣ 队列大小 &#x2F; 是否为空"></a>4️⃣ 队列大小 &#x2F; 是否为空</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; q.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (q.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;queue is empty&quot;</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="三、遍历队列（注意！不能直接用-range-for）"><a href="#三、遍历队列（注意！不能直接用-range-for）" class="headerlink" title="三、遍历队列（注意！不能直接用 range-for）"></a>三、遍历队列（注意！不能直接用 range-for）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure><p>✅ 注意：<strong>pop 会改变队列</strong>，遍历过程中会删除元素。</p><hr><h2 id="四、队列常见应用场景"><a href="#四、队列常见应用场景" class="headerlink" title="四、队列常见应用场景"></a>四、队列常见应用场景</h2><h3 id="1️⃣-BFS（广度优先搜索）"><a href="#1️⃣-BFS（广度优先搜索）" class="headerlink" title="1️⃣ BFS（广度优先搜索）"></a>1️⃣ BFS（广度优先搜索）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="comment">// 处理 u</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : graph[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">            visited[v] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2️⃣-滑动窗口、缓存"><a href="#2️⃣-滑动窗口、缓存" class="headerlink" title="2️⃣ 滑动窗口、缓存"></a>2️⃣ 滑动窗口、缓存</h3><ul><li><code>queue</code> 可以做 FIFO 缓存（先进先出）</li><li>可以结合 <code>deque</code> 做滑动窗口最大值</li></ul><hr><h2 id="五、priority-queue（进阶）"><a href="#五、priority-queue（进阶）" class="headerlink" title="五、priority_queue（进阶）"></a>五、<code>priority_queue</code>（进阶）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">// 默认大顶堆</span></span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; pq.<span class="built_in">top</span>(); <span class="comment">// 5</span></span><br><span class="line">pq.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; pq.<span class="built_in">top</span>(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li><strong>小顶堆</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br></pre></td></tr></table></figure><hr><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li><code>queue</code> &#x3D; 先进先出，操作：<code>push</code>、<code>pop</code>、<code>front</code>、<code>back</code></li><li>遍历只能通过 <strong>while(!empty()) pop</strong></li><li>竞赛常用于 <strong>BFS、缓存、滑动窗口</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++算法知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>map的用法</title>
      <link href="/2025/12/21/11-map%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2025/12/21/11-map%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、map-是什么"><a href="#一、map-是什么" class="headerlink" title="一、map 是什么"></a>一、<code>map</code> 是什么</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line">map&lt;Key, Value&gt; mp;</span><br></pre></td></tr></table></figure><ul><li><strong>键值对（key → value）</strong></li><li><strong>key 自动有序（默认升序）</strong></li><li><strong>底层是红黑树</strong></li><li>操作复杂度：<strong>O(log n)</strong></li></ul><hr><h2 id="二、基本用法"><a href="#二、基本用法" class="headerlink" title="二、基本用法"></a>二、基本用法</h2><h3 id="1️⃣-插入元素"><a href="#1️⃣-插入元素" class="headerlink" title="1️⃣ 插入元素"></a>1️⃣ 插入元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line">mp[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">mp[<span class="number">3</span>] = <span class="number">30</span>;</span><br><span class="line">mp[<span class="number">2</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>⚠️ <strong>用 <code>[]</code> 插入，如果 key 不存在，会自动创建并初始化 value</strong></p><hr><h3 id="2️⃣-访问元素"><a href="#2️⃣-访问元素" class="headerlink" title="2️⃣ 访问元素"></a>2️⃣ 访问元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; mp[<span class="number">2</span>];   <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>❗注意：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; mp[<span class="number">100</span>];   <span class="comment">// 不存在，但会创建 key=100，value=0</span></span><br></pre></td></tr></table></figure><hr><h3 id="3️⃣-判断-key-是否存在（很重要）"><a href="#3️⃣-判断-key-是否存在（很重要）" class="headerlink" title="3️⃣ 判断 key 是否存在（很重要）"></a>3️⃣ 判断 key 是否存在（很重要）</h3><p>❌ 错误写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mp[x])  <span class="comment">// 不可靠</span></span><br></pre></td></tr></table></figure><p>✅ 正确写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mp.<span class="built_in">count</span>(x))  <span class="comment">// 返回 0 或 1</span></span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mp.<span class="built_in">find</span>(x) != mp.<span class="built_in">end</span>())</span><br></pre></td></tr></table></figure><hr><h3 id="4️⃣-删除元素"><a href="#4️⃣-删除元素" class="headerlink" title="4️⃣ 删除元素"></a>4️⃣ 删除元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp.<span class="built_in">erase</span>(<span class="number">2</span>);          <span class="comment">// 按 key 删除</span></span><br><span class="line">mp.<span class="built_in">erase</span>(mp.<span class="built_in">begin</span>()); <span class="comment">// 删除迭代器指向的元素</span></span><br></pre></td></tr></table></figure><hr><h3 id="5️⃣-map-的大小"><a href="#5️⃣-map-的大小" class="headerlink" title="5️⃣ map 的大小"></a>5️⃣ map 的大小</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sz = mp.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><hr><h2 id="三、遍历-map（必会）"><a href="#三、遍历-map（必会）" class="headerlink" title="三、遍历 map（必会）"></a>三、遍历 map（必会）</h2><h3 id="1️⃣-用迭代器"><a href="#1️⃣-用迭代器" class="headerlink" title="1️⃣ 用迭代器"></a>1️⃣ 用迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2️⃣-用-range-for（推荐）"><a href="#2️⃣-用-range-for（推荐）" class="headerlink" title="2️⃣ 用 range-for（推荐）"></a>2️⃣ 用 range-for（推荐）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : mp) &#123;</span><br><span class="line">    cout &lt;&lt; p.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四、map-的有序性（考试常考）"><a href="#四、map-的有序性（考试常考）" class="headerlink" title="四、map 的有序性（考试常考）"></a>四、map 的有序性（考试常考）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="number">3</span>] = <span class="number">30</span>;</span><br><span class="line">mp[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">mp[<span class="number">2</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>遍历输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 10</span><br><span class="line">2 20</span><br><span class="line">3 30</span><br></pre></td></tr></table></figure><p>👉 <strong>自动按 key 从小到大排序</strong></p><hr><h2 id="五、常见应用场景"><a href="#五、常见应用场景" class="headerlink" title="五、常见应用场景"></a>五、常见应用场景</h2><h3 id="1️⃣-统计次数（最常用）"><a href="#1️⃣-统计次数（最常用）" class="headerlink" title="1️⃣ 统计次数（最常用）"></a>1️⃣ 统计次数（最常用）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : a) &#123;</span><br><span class="line">    cnt[x]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2️⃣-字符-字符串计数"><a href="#2️⃣-字符-字符串计数" class="headerlink" title="2️⃣ 字符 &#x2F; 字符串计数"></a>2️⃣ 字符 &#x2F; 字符串计数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; cnt;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : s) cnt[c]++;</span><br></pre></td></tr></table></figure><hr><h3 id="3️⃣-映射关系"><a href="#3️⃣-映射关系" class="headerlink" title="3️⃣ 映射关系"></a>3️⃣ 映射关系</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">&quot;apple&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">mp[<span class="string">&quot;banana&quot;</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="六、map-vs-unordered-map"><a href="#六、map-vs-unordered-map" class="headerlink" title="六、map vs unordered_map"></a>六、<code>map</code> vs <code>unordered_map</code></h2><table><thead><tr><th>对比</th><th>map</th><th>unordered_map</th></tr></thead><tbody><tr><td>是否有序</td><td>✅ 有序</td><td>❌ 无序</td></tr><tr><td>底层</td><td>红黑树</td><td>哈希表</td></tr><tr><td>复杂度</td><td>O(log n)</td><td>平均 O(1)</td></tr><tr><td>竞赛安全性</td><td>✅ 稳定</td><td>❌ 可能被卡</td></tr></tbody></table><p>👉 <strong>竞赛默认用 <code>map</code>，追求速度才用 <code>unordered_map</code></strong></p><hr><h2 id="七、自定义排序（进阶）"><a href="#七、自定义排序（进阶）" class="headerlink" title="七、自定义排序（进阶）"></a>七、自定义排序（进阶）</h2><h3 id="key-降序"><a href="#key-降序" class="headerlink" title="key 降序"></a>key 降序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; mp;</span><br></pre></td></tr></table></figure><hr><h2 id="八、常见坑总结（很重要）"><a href="#八、常见坑总结（很重要）" class="headerlink" title="八、常见坑总结（很重要）"></a>八、常见坑总结（很重要）</h2><p>❌ <strong><code>mp[x]</code> 判断存在性</strong><br>❌ <strong>忘记 map 自动排序</strong><br>❌ <strong>遍历时 erase 当前迭代器（会崩）</strong></p><p>✅ 正确删除写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second == <span class="number">0</span>)</span><br><span class="line">        it = mp.<span class="built_in">erase</span>(it);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="九、一句话记忆版"><a href="#九、一句话记忆版" class="headerlink" title="九、一句话记忆版"></a>九、一句话记忆版</h2><blockquote><p><strong>map &#x3D; 有序的键值对容器，自动排序，查找&#x2F;插入 O(log n)</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++算法知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2025/12/20/4-%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2025/12/20/4-%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">ksm</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) res = res * a % m;</span><br><span class="line">        a = a * a % m, x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个**快速幂（Binary Exponentiation &#x2F; 快速取模幂）**函数，用来计算：</p><p>$$<br>(a^x) \bmod m<br>$$<br>逐行直接讲代码逻辑 👇（按你偏好，给结论型解释）</p><hr><h3 id="函数整体作用"><a href="#函数整体作用" class="headerlink" title="函数整体作用"></a>函数整体作用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span></span></span><br></pre></td></tr></table></figure><p> 计算 <strong>a 的 x 次方，对 m 取模</strong><br>等价于：<code>pow(a, x) % m</code>，但<strong>更快、更安全</strong></p><hr><h3 id="变量含义"><a href="#变量含义" class="headerlink" title="变量含义"></a>变量含义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li><code>res</code>：保存最终结果</li><li>初始为 1，因为乘法单位元是 1</li></ul><hr><h3 id="核心循环"><a href="#核心循环" class="headerlink" title="核心循环"></a>核心循环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(x) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>只要指数 <code>x &gt; 0</code> 就继续</li><li>每一轮把 <code>x</code> <strong>二进制右移一位</strong></li></ul><hr><h3 id="判断当前二进制位"><a href="#判断当前二进制位" class="headerlink" title="判断当前二进制位"></a>判断当前二进制位</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &amp; <span class="number">1</span>) res = res * a % m;</span><br></pre></td></tr></table></figure><ul><li><code>x &amp; 1</code>：判断 <strong>x 的最低位是否为 1</strong></li><li>如果是 1，说明当前这一位需要参与乘法</li><li>把当前的 <code>a</code> 乘进结果中</li></ul><p> 对应二进制拆分：<br>$$<br>a^{13} &#x3D; a^{1101_2} &#x3D; a^8 \cdot a^4 \cdot a^1<br>$$</p><hr><h3 id="底数平方-指数右移"><a href="#底数平方-指数右移" class="headerlink" title="底数平方 &amp; 指数右移"></a>底数平方 &amp; 指数右移</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = a * a % m;</span><br><span class="line">x &gt;&gt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>a = a * a % m</code><br> 每一轮把 <code>a</code> 变成：<br>$$<br>a,\ a^2,\ a^4,\ a^8,\ a^{16}…<br>$$</p></li><li><p><code>x &gt;&gt;= 1</code><br> 相当于 <code>x = x / 2</code>，处理下一位二进制</p></li></ul><hr><h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>最终得到：<br>$$<br>res &#x3D; a^x \bmod m<br>$$</p><hr><h3 id="举个例子（a-3-x-5-m-7）"><a href="#举个例子（a-3-x-5-m-7）" class="headerlink" title="举个例子（a &#x3D; 3, x &#x3D; 5, m &#x3D; 7）"></a>举个例子（a &#x3D; 3, x &#x3D; 5, m &#x3D; 7）</h3><table><thead><tr><th>x(二进制)</th><th>res</th><th>a</th></tr></thead><tbody><tr><td>101</td><td>1</td><td>3</td></tr><tr><td>1 → 乘</td><td>3</td><td>3</td></tr><tr><td>10</td><td>3</td><td>2</td></tr><tr><td>0</td><td>3</td><td>4</td></tr><tr><td>1 → 乘</td><td>5</td><td>2</td></tr></tbody></table><p>结果：<code>3^5 % 7 = 5</code></p><hr><h3 id="为什么用快速幂？"><a href="#为什么用快速幂？" class="headerlink" title="为什么用快速幂？"></a>为什么用快速幂？</h3><table><thead><tr><th>方法</th><th>时间复杂度</th></tr></thead><tbody><tr><td>普通循环</td><td>O(x)</td></tr><tr><td>快速幂</td><td><strong>O(log x)</strong> ✅</td></tr></tbody></table><p> 在**大指数（如 10^9）**时差别巨大</p><hr><h3 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h3><ul><li>取模幂运算（竞赛 &#x2F; 算法题）</li><li>费马小定理</li><li>逆元计算</li><li>RSA &#x2F; 密码学</li></ul>]]></content>
      
      
      <categories>
          
          <category> c++算法知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈stack的用法</title>
      <link href="/2025/12/19/9-%E6%A0%88stack%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2025/12/19/9-%E6%A0%88stack%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="stack-是什么？"><a href="#stack-是什么？" class="headerlink" title="stack 是什么？"></a><code>stack</code> 是什么？</h2><p><code>stack</code> 是 <strong>栈</strong>，一种 <strong>后进先出（LIFO）</strong> 的数据结构。</p><p> 类比：一摞盘子</p><ul><li>只能从 <strong>顶部</strong> 放</li><li>只能从 <strong>顶部</strong> 取</li></ul><hr><h2 id="需要的头文件"><a href="#需要的头文件" class="headerlink" title="需要的头文件"></a>需要的头文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure><p>通常还会配合：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><hr><h2 id="定义一个栈"><a href="#定义一个栈" class="headerlink" title="定义一个栈"></a>定义一个栈</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;        <span class="comment">// 存 int</span></span><br><span class="line">stack&lt;string&gt; st2;   <span class="comment">// 存 string</span></span><br></pre></td></tr></table></figure><p><code>stack&lt;T&gt;</code> 中的 <code>T</code> 可以是任意类型。</p><hr><h2 id="常用成员函数（核心）"><a href="#常用成员函数（核心）" class="headerlink" title="常用成员函数（核心）"></a>常用成员函数（核心）</h2><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>st.push(x)</code></td><td>入栈</td></tr><tr><td><code>st.pop()</code></td><td>出栈（不返回值）</td></tr><tr><td><code>st.top()</code></td><td>访问栈顶元素</td></tr><tr><td><code>st.empty()</code></td><td>是否为空</td></tr><tr><td><code>st.size()</code></td><td>元素个数</td></tr></tbody></table><p><strong>注意</strong>：</p><ul><li><code>pop()</code> <strong>不会返回元素</strong></li><li>取元素用 <code>top()</code></li></ul><hr><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    st.<span class="built_in">pop</span>();                <span class="comment">// 弹出 3</span></span><br><span class="line">    cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; st.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><hr><h2 id="遍历-stack（常见坑）"><a href="#遍历-stack（常见坑）" class="headerlink" title="遍历 stack（常见坑）"></a>遍历 stack（常见坑）</h2><p><code>stack</code> <strong>不能直接遍历</strong>（没有迭代器）</p><p>✅ 正确方式：<strong>边弹边访问</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这会 <strong>清空栈</strong></p><hr><h2 id="安全使用（必须判断）"><a href="#安全使用（必须判断）" class="headerlink" title="安全使用（必须判断）"></a>安全使用（必须判断）</h2><p>错误写法（可能崩溃）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; st.<span class="built_in">top</span>(); <span class="comment">// 如果栈为空</span></span><br></pre></td></tr></table></figure><p> 正确写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; st.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="stack-的底层实现（了解）"><a href="#stack-的底层实现（了解）" class="headerlink" title="stack 的底层实现（了解）"></a>stack 的底层实现（了解）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br></pre></td></tr></table></figure><p>默认底层是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt;</span><br></pre></td></tr></table></figure><p>你也可以指定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; st;</span><br></pre></td></tr></table></figure><p>但 <strong>99% 不需要关心</strong></p><hr><h2 id="常见应用场景（非常重要）"><a href="#常见应用场景（非常重要）" class="headerlink" title="常见应用场景（非常重要）"></a>常见应用场景（非常重要）</h2><h3 id="1-括号匹配"><a href="#1-括号匹配" class="headerlink" title="1. 括号匹配"></a>1. 括号匹配</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(c);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-单调栈（竞赛必考）"><a href="#2-单调栈（竞赛必考）" class="headerlink" title="2. 单调栈（竞赛必考）"></a>2. 单调栈（竞赛必考）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; a[st.<span class="built_in">top</span>()] &gt; a[i]) &#123;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    st.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++算法知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>find()的用法</title>
      <link href="/2025/12/18/8-find/"/>
      <url>/2025/12/18/8-find/</url>
      
        <content type="html"><![CDATA[<h2 id="一、std-find（最常用）"><a href="#一、std-find（最常用）" class="headerlink" title="一、std::find（最常用）"></a>一、<code>std::find</code>（最常用）</h2><p><strong>头文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>原型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIt <span class="title">find</span><span class="params">(InputIt first, InputIt last, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>作用</strong></p><blockquote><p>在区间 <code>[first, last)</code> 中查找 <strong>第一个等于 value 的元素</strong></p></blockquote><hr><h3 id="1️⃣-在-vector-中查找"><a href="#1️⃣-在-vector-中查找" class="headerlink" title="1️⃣ 在 vector 中查找"></a>1️⃣ 在 <code>vector</code> 中查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (it != a.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到了，下标 = &quot;</span> &lt;&lt; it - a.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>📌 关键点</p><ul><li>返回的是 <strong>迭代器</strong></li><li>没找到 → 返回 <code>end()</code></li></ul><hr><h3 id="2️⃣-在数组中查找"><a href="#2️⃣-在数组中查找" class="headerlink" title="2️⃣ 在数组中查找"></a>2️⃣ 在数组中查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line"><span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(a, a + n, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (it != a + n) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到了，位置 = &quot;</span> &lt;&lt; it - a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3️⃣-在-string（字符层面）中用-std-find"><a href="#3️⃣-在-string（字符层面）中用-std-find" class="headerlink" title="3️⃣ 在 string（字符层面）中用 std::find"></a>3️⃣ 在 <code>string</code>（字符层面）中用 <code>std::find</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (it != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到了，位置 = &quot;</span> &lt;&lt; it - s.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ 注意：<br>这是 <strong>algorithm 的 find</strong>，不是字符串成员函数。</p><hr><h2 id="二、string-find（字符串专用）"><a href="#二、string-find（字符串专用）" class="headerlink" title="二、string::find（字符串专用）"></a>二、<code>string::find</code>（字符串专用）</h2><p><strong>头文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="4️⃣-查找子串（最常见）"><a href="#4️⃣-查找子串（最常见）" class="headerlink" title="4️⃣ 查找子串（最常见）"></a>4️⃣ 查找子串（最常见）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos = s.<span class="built_in">find</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos != string::npos) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;起始位置 = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>📌</p><ul><li>返回 <strong>下标</strong></li><li>找不到 → <code>string::npos</code></li></ul><hr><h3 id="5️⃣-从指定位置开始找"><a href="#5️⃣-从指定位置开始找" class="headerlink" title="5️⃣ 从指定位置开始找"></a>5️⃣ 从指定位置开始找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;ababab&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos = s.<span class="built_in">find</span>(<span class="string">&quot;ab&quot;</span>, <span class="number">2</span>); <span class="comment">// 从下标 2 开始</span></span><br><span class="line">cout &lt;&lt; pos &lt;&lt; endl;      <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><hr><h3 id="6️⃣-查找字符"><a href="#6️⃣-查找字符" class="headerlink" title="6️⃣ 查找字符"></a>6️⃣ 查找字符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos = s.<span class="built_in">find</span>(<span class="string">&#x27;c&#x27;</span>);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><hr><h2 id="三、find-vs-string-find-对比（必会）"><a href="#三、find-vs-string-find-对比（必会）" class="headerlink" title="三、find vs string::find 对比（必会）"></a>三、<code>find</code> vs <code>string::find</code> 对比（必会）</h2><table><thead><tr><th>对比点</th><th>std::find</th><th>string::find</th></tr></thead><tbody><tr><td>头文件</td><td><code>&lt;algorithm&gt;</code></td><td><code>&lt;string&gt;</code></td></tr><tr><td>返回值</td><td>迭代器</td><td>下标</td></tr><tr><td>适用对象</td><td>所有容器</td><td>仅 <code>string</code></td></tr><tr><td>未找到</td><td><code>end()</code></td><td><code>string::npos</code></td></tr></tbody></table><hr><h2 id="四、常见错误（很重要）"><a href="#四、常见错误（很重要）" class="headerlink" title="四、常见错误（很重要）"></a>四、常见错误（很重要）</h2><p>❌ <strong>忘了判断是否找到</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), x);</span><br><span class="line">cout &lt;&lt; *it; <span class="comment">// ❌ 如果没找到会崩</span></span><br></pre></td></tr></table></figure><p>✔️ 正确写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>❌ <strong>混淆两个 find</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">// ❌</span></span><br></pre></td></tr></table></figure><p>✔️</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>);        <span class="comment">// string::find</span></span><br><span class="line"><span class="built_in">find</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="string">&#x27;a&#x27;</span>); <span class="comment">// std::find</span></span><br></pre></td></tr></table></figure><hr><h2 id="五、时间复杂度（竞赛要知道）"><a href="#五、时间复杂度（竞赛要知道）" class="headerlink" title="五、时间复杂度（竞赛要知道）"></a>五、时间复杂度（竞赛要知道）</h2><ul><li><code>std::find</code>：<strong>O(n)</strong>（顺序查找）</li><li><code>string::find</code>：通常 <strong>O(n)</strong></li></ul><p>⚠️ 若需要快速查找：</p><ul><li><code>set / map</code> → <code>find()</code> 是 <strong>O(log n)</strong></li><li><code>unordered_map</code> → 平均 <strong>O(1)</strong></li></ul><hr><h2 id="六、一句话总结"><a href="#六、一句话总结" class="headerlink" title="六、一句话总结"></a>六、一句话总结</h2><blockquote><p><strong>容器找元素用 <code>std::find</code>，字符串找子串用 <code>string::find</code></strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++算法知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sort的用法</title>
      <link href="/2025/11/11/7-sort/"/>
      <url>/2025/11/11/7-sort/</url>
      
        <content type="html"><![CDATA[<p>这句代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums<span class="number">1.</span><span class="built_in">begin</span>(), nums<span class="number">1.</span><span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>是 <strong>C++ STL（标准模板库）</strong> 中用来 <strong>对容器内容进行排序</strong> 的语句。<br> 我们来一步一步解释👇</p><hr><h2 id="一、sort-是什么"><a href="#一、sort-是什么" class="headerlink" title="一、sort() 是什么"></a>一、<code>sort()</code> 是什么</h2><p><code>sort()</code> 是 C++ 标准库中的一个排序函数，定义在头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><p>它能对一段范围（区间）的数据按 <strong>升序（从小到大）</strong> 排序。</p><hr><h2 id="二、nums1-begin-和-nums1-end-是什么"><a href="#二、nums1-begin-和-nums1-end-是什么" class="headerlink" title="二、nums1.begin() 和 nums1.end() 是什么"></a>二、<code>nums1.begin()</code> 和 <code>nums1.end()</code> 是什么</h2><p>假设：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums1 = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>nums1.begin()</code>：指向 <code>nums1</code> 第一个元素（即 <code>5</code>）的迭代器。</li><li><code>nums1.end()</code>：指向 <strong>最后一个元素的下一个位置</strong>（即超尾元素）。</li></ul><p>所以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums<span class="number">1.</span><span class="built_in">begin</span>(), nums<span class="number">1.</span><span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>表示让 <code>sort()</code> 对整个 <code>nums1</code> 里的元素排序。</p><hr><h2 id="三、执行结果示例"><a href="#三、执行结果示例" class="headerlink" title="三、执行结果示例"></a>三、执行结果示例</h2><p>执行前：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums1 = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums<span class="number">1.</span><span class="built_in">begin</span>(), nums<span class="number">1.</span><span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>执行后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure><p>默认按 <strong>从小到大</strong> 排序。</p><hr><h2 id="四、如果想改为从大到小排序"><a href="#四、如果想改为从大到小排序" class="headerlink" title="四、如果想改为从大到小排序"></a>四、如果想改为从大到小排序</h2><p>可以传第三个参数（比较函数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums<span class="number">1.</span><span class="built_in">begin</span>(), nums<span class="number">1.</span><span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums1 = &#123;<span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table><thead><tr><th>部分</th><th>含义</th></tr></thead><tbody><tr><td><code>sort()</code></td><td>C++ 排序函数</td></tr><tr><td><code>nums1.begin()</code></td><td>第一个元素</td></tr><tr><td><code>nums1.end()</code></td><td>最后一个元素的下一个位置</td></tr><tr><td><code>sort(nums1.begin(), nums1.end())</code></td><td>对整个 <code>nums1</code> 升序排序</td></tr><tr><td><code>sort(nums1.begin(), nums1.end(), greater&lt;int&gt;())</code></td><td>对整个 <code>nums1</code> 降序排序</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> c++算法知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.乘法取模的分配律</title>
      <link href="/2025/09/30/6-%E4%B9%98%E6%B3%95%E5%8F%96%E6%A8%A1/"/>
      <url>/2025/09/30/6-%E4%B9%98%E6%B3%95%E5%8F%96%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr[n - k + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">       cout &lt;&lt; arr[n] % MOD;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>(a⋅b)modp &#x3D; ((amodp)⋅(bmodp))modp &#x3D; (amodp * b)modp</p><p>仔细想一下就会得出</p><p>由上式子(x1⋅x2⋅⋯⋅xk)modp &#x3D; (((x1modp)⋅x2)modp⋯xm)modp</p><p>这个公式如果不理解，可以从右式子逐步化简，最后就能得到左边式子。</p>]]></content>
      
      
      <categories>
          
          <category> c++算法知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.Access Control List(访问控制列表)简要介绍</title>
      <link href="/2025/09/26/5-ACL%E6%9D%83%E9%99%90%E8%AE%B2%E8%A7%A3/"/>
      <url>/2025/09/26/5-ACL%E6%9D%83%E9%99%90%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>ACL 的全称是 <strong>Access Control List（访问控制列表）</strong>，它是一种 <strong>比传统文件权限（rwx）更灵活的权限控制机制</strong>。</p><p>在 Linux&#x2F;Unix 系统中，文件的权限通常用 <code>rwx</code>（读、写、执行）和 <code>所有者 / 用户组 / 其他人</code> 来控制，但这种方式有个缺陷：<br> 👉 只能针对 <strong>一个所有者、一个用户组和所有其他人</strong> 设置权限。</p><p>ACL 的作用就是 <strong>突破这个限制</strong>：</p><ul><li>允许你针对 <strong>多个用户</strong> 或 <strong>多个用户组</strong> 分别设置不同的权限。</li><li>更细粒度地控制文件和目录的访问。</li></ul><hr><h3 id="🔑-ACL-的核心点"><a href="#🔑-ACL-的核心点" class="headerlink" title="🔑 ACL 的核心点"></a>🔑 ACL 的核心点</h3><ol><li><strong>文件基本权限</strong>（Owner &#x2F; Group &#x2F; Other）<ul><li><code>rwx</code> 三种权限，传统方式。</li></ul></li><li><strong>扩展权限</strong>（通过 ACL 设置）<ul><li>你可以给指定的用户或用户组单独设置权限。</li></ul></li><li><strong>默认 ACL</strong>（只对目录有效）<ul><li>指定目录下新建的文件&#x2F;子目录会自动继承 ACL 权限。</li></ul></li></ol><hr><h3 id="📌-常用命令"><a href="#📌-常用命令" class="headerlink" title="📌 常用命令"></a>📌 常用命令</h3><ol><li><p><strong>查看 ACL</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getfacl 文件名</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file: test.txt</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line">user::rw-</span><br><span class="line">user:alice:r--</span><br><span class="line">group::r--</span><br><span class="line">mask::rw-</span><br><span class="line">other::r--</span><br></pre></td></tr></table></figure><p>表示 <code>alice</code> 用户对 <code>test.txt</code> 有单独的 <code>r--</code> 权限。</p></li><li><p><strong>设置 ACL</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setfacl -m u:alice:r test.txt    <span class="comment"># 给用户 alice 读权限</span></span><br><span class="line">setfacl -m g:devs:rw test.txt    <span class="comment"># 给用户组 devs 读写权限</span></span><br></pre></td></tr></table></figure></li><li><p><strong>删除 ACL</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setfacl -x u:alice test.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>清空所有 ACL</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setfacl -b test.txt</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="📊-举个例子"><a href="#📊-举个例子" class="headerlink" title="📊 举个例子"></a>📊 举个例子</h3><p>假设有个文件 <code>report.docx</code>，默认权限是 <code>rw-------</code>（只有 owner 能读写）。<br> 但现在要求：</p><ul><li>用户 <code>bob</code> 也能读</li><li>用户组 <code>devs</code> 能读写</li></ul><p>用 ACL 可以这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setfacl -m u:bob:r report.docx</span><br><span class="line">setfacl -m g:devs:rw report.docx</span><br></pre></td></tr></table></figure><hr><p>👉 总结一句话：<br> <strong>ACL 是对传统 Linux 权限的补充，能实现更灵活、更细粒度的权限控制</strong>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>4.如何配置python才能在Pycharm中使用opencv和numpy</title>
      <link href="/2025/09/24/10-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEpython%E6%89%8D%E8%83%BD%E5%9C%A8Pycharm%E4%B8%AD%E4%BD%BF%E7%94%A8opencv%E5%92%8Cnumpy/"/>
      <url>/2025/09/24/10-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEpython%E6%89%8D%E8%83%BD%E5%9C%A8Pycharm%E4%B8%AD%E4%BD%BF%E7%94%A8opencv%E5%92%8Cnumpy/</url>
      
        <content type="html"><![CDATA[<h1 id="通过Homebrew下载好python后-用终端运行下面代码"><a href="#通过Homebrew下载好python后-用终端运行下面代码" class="headerlink" title="通过Homebrew下载好python后,用终端运行下面代码"></a>通过Homebrew下载好python后,用终端运行下面代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 安装 Python 3.12</span><br><span class="line">brew install python@3.12</span><br><span class="line"></span><br><span class="line"># 创建虚拟环境</span><br><span class="line">python3.12 -m venv opencv_env</span><br><span class="line"></span><br><span class="line"># 激活虚拟环境</span><br><span class="line">source opencv_env/bin/activate</span><br><span class="line"></span><br><span class="line"># 安装 opencv 和 numpy</span><br><span class="line">pip install --upgrade pip</span><br><span class="line">pip install opencv-python numpy</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>已经在 <strong>Python 3.12 的虚拟环境 <code>opencv_env</code></strong> 里成功安装了 <code>opencv-python</code> 和 <code>numpy</code>。</p><p>你在终端里 <code>import cv2</code> 应该已经没问题了。现在 PyCharm 用不了，是因为 <strong>PyCharm 没有切换到你刚刚的虚拟环境解释器</strong>。</p><hr><h3 id="🔧-在-PyCharm-配置正确的虚拟环境"><a href="#🔧-在-PyCharm-配置正确的虚拟环境" class="headerlink" title="🔧 在 PyCharm 配置正确的虚拟环境"></a>🔧 在 PyCharm 配置正确的虚拟环境</h3><ol><li><p>打开 PyCharm，进入你的项目。</p></li><li><p>点击菜单栏 <strong>PyCharm → Settings（偏好设置）</strong>。</p></li><li><p>左边找到：<strong>Project: 你的项目名 → Python Interpreter</strong>解释器。</p></li><li><p>右上角点 <strong>⚙️ → Add Interpreter</strong>（添加解释器）。</p></li><li><p>选择 <strong>Add Local Interpreter → Existing environment</strong>（一定要点<strong>选择现有</strong>，当时浪费好多时间）。</p></li><li><p>浏览选择你虚拟环境的 Python 解释器路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/youhan152/opencv_env/bin/python3.12</span><br></pre></td></tr></table></figure></li><li><p>点击 OK，等待 PyCharm 重新加载。</p></li></ol><hr><h3 id="✅-检查方法"><a href="#✅-检查方法" class="headerlink" title="✅ 检查方法"></a>✅ 检查方法</h3><p>在 PyCharm 的 Python Console 或你的项目代码里输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="built_in">print</span>(cv2.__version__)</span><br></pre></td></tr></table></figure><p>应该能正常输出 OpenCV 的版本号，比如 <code>4.12.0</code>。</p><p>这样就能正确在py文件里面正确调用cv2和numpy了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3.Uikit的MVVM模式</title>
      <link href="/2025/09/23/3-Uikit%E7%9A%84MVVM%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/09/23/3-Uikit%E7%9A%84MVVM%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>我们来详细讲解 <strong>在 UIKit 中实现 MVVM</strong> 的设计模式。这与 SwiftUI 中的 MVVM 核心思想一致，但由于 UIKit 是命令式框架，实现方式上有所不同。</p><hr><h3 id="1-核心思想回顾"><a href="#1-核心思想回顾" class="headerlink" title="1. 核心思想回顾"></a>1. 核心思想回顾</h3><p>MVVM 的核心永远是<strong>分离关注点</strong>：</p><ul><li><strong>Model</strong>: 数据和业务逻辑。</li><li><strong>View</strong>: UI 呈现（<code>UIView</code>, <code>UIViewController</code>）。</li><li><strong>ViewModel</strong>: 将 Model 转换为 View 可显示的状态，并处理 View 的交互逻辑。</li></ul><p>在 UIKit 中，<strong><code>UIViewController</code>及其管理的 <code>UIView</code>共同被视为 “V” (View层)</strong>。</p><hr><h3 id="2-各组件职责（UIKit-版）"><a href="#2-各组件职责（UIKit-版）" class="headerlink" title="2. 各组件职责（UIKit 版）"></a>2. 各组件职责（UIKit 版）</h3><table><thead><tr><th>组件</th><th>职责</th><th>具体任务</th></tr></thead><tbody><tr><td><strong>Model</strong></td><td>数据与业务规则</td><td>- 数据模型 (Struct&#x2F;Class) - 网络请求 (NetworkService) - 数据库操作 (PersistenceService)</td></tr><tr><td><strong>View</strong></td><td>显示UI &amp; 用户交互</td><td>- <strong><code>UIViewController</code></strong> 和 <strong><code>UIView</code></strong> - 负责<strong>创建和布局</strong>UI组件 - 通过 <strong>委托、IBAction、Target-Action</strong> 接收用户输入 - <strong>监听</strong> ViewModel 的状态变化并更新UI</td></tr><tr><td><strong>ViewModel</strong></td><td>状态管理与逻辑处理</td><td>- 暴露 <strong>属性和命令</strong> 供 View 绑定 - 处理来自 View 的<strong>用户输入</strong> - 调用 Model 层进行<strong>数据获取和处理</strong> - 将 Model 的数据<strong>转换</strong>为 View 易于使用的格式</td></tr></tbody></table><hr><h3 id="3-关键技术：数据绑定-Data-Binding"><a href="#3-关键技术：数据绑定-Data-Binding" class="headerlink" title="3. 关键技术：数据绑定 (Data Binding)"></a>3. 关键技术：数据绑定 (Data Binding)</h3><p>由于 UIKit 没有 SwiftUI 那样的内置响应式机制，实现 <strong>数据绑定</strong> 是 UIKit MVVM 的核心挑战。主要有以下几种方式：</p><h4 id="方式一：使用-Combine-框架-iOS-13-【现代推荐】"><a href="#方式一：使用-Combine-框架-iOS-13-【现代推荐】" class="headerlink" title="方式一：使用 Combine 框架 (iOS 13+)【现代推荐】"></a>方式一：使用 Combine 框架 (iOS 13+)<strong>【现代推荐】</strong></h4><p>这是最接近 SwiftUI 体验的方式。ViewModel 使用 <code>@Published</code>属性，View 使用 <code>sink</code>来订阅。</p><p><strong>ViewModel:</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  SearchViewViewModel.swift</span></span><br><span class="line"><span class="comment">//  TwitterClone</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Amr Hossam on 10/03/2024.</span></span><br><span class="line"><span class="comment">//  数据转换为view层直接可用的格式，viewmodel的职责之一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> Combine</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SearchViewViewModel</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> subscriptions: <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt; <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">search</span>(<span class="params">with</span> <span class="params">query</span>: <span class="type">String</span>, <span class="keyword">_</span> <span class="params">completion</span>: <span class="keyword">@escaping</span> ([<span class="type">TwitterUser</span>]) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="type">DatabaseManager</span>.shared.collectionUsers(search: query)</span><br><span class="line">            .sink &#123; completion <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">case</span> .failure(<span class="keyword">let</span> error) <span class="operator">=</span> completion &#123;</span><br><span class="line">                    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; receiveValue: &#123; users <span class="keyword">in</span></span><br><span class="line">                completion(users)</span><br><span class="line">            &#125;</span><br><span class="line">            .store(in: <span class="operator">&amp;</span>subscriptions)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>View (UIViewController):</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//</span></span><br><span class="line"><span class="comment">//  SearchViewController.swift</span></span><br><span class="line"><span class="comment">//  TwitterClone</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Amr Hossam on 22/02/2022.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SearchViewController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> searchController: <span class="type">UISearchController</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> searchController <span class="operator">=</span> <span class="type">UISearchController</span>(searchResultsController: <span class="type">SearchResultsViewController</span>())</span><br><span class="line">        searchController.searchBar.searchBarStyle <span class="operator">=</span> .minimal</span><br><span class="line">        searchController.searchBar.placeholder <span class="operator">=</span> <span class="string">&quot;Search with @usernames&quot;</span></span><br><span class="line">        <span class="keyword">return</span> searchController</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> promptLabel: <span class="type">UILabel</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> label <span class="operator">=</span> <span class="type">UILabel</span>()</span><br><span class="line">        label.text <span class="operator">=</span> <span class="string">&quot;Search for users and get connected&quot;</span></span><br><span class="line">        label.textAlignment <span class="operator">=</span> .center</span><br><span class="line">        label.numberOfLines <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        label.font <span class="operator">=</span> .systemFont(ofSize: <span class="number">32</span>, weight: .bold)</span><br><span class="line">        label.textColor <span class="operator">=</span> .placeholderText</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> viewModel: <span class="type">SearchViewViewModel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">viewModel</span>: <span class="type">SearchViewViewModel</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.viewModel <span class="operator">=</span> viewModel</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init?</span>(<span class="params">coder</span>: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">&quot;init(coder:) has not been implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        view.addSubview(promptLabel)</span><br><span class="line">        navigationItem.searchController <span class="operator">=</span> searchController</span><br><span class="line">        searchController.searchResultsUpdater <span class="operator">=</span> <span class="keyword">self</span></span><br><span class="line">        configureConstraints()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">configureConstraints</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> promptLabelConstraints <span class="operator">=</span> [</span><br><span class="line">            promptLabel.centerYAnchor.constraint(equalTo: view.centerYAnchor),</span><br><span class="line">            promptLabel.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: <span class="number">20</span>),</span><br><span class="line">            promptLabel.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: <span class="operator">-</span><span class="number">20</span>)</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate(promptLabelConstraints)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">SearchViewController</span>: <span class="title class_ inherited__">UISearchResultsUpdating</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateSearchResults</span>(<span class="params">for</span> <span class="params">searchController</span>: <span class="type">UISearchController</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> resultsViewController <span class="operator">=</span> searchController.searchResultsController <span class="keyword">as?</span> <span class="type">SearchResultsViewController</span>,</span><br><span class="line">              <span class="keyword">let</span> query <span class="operator">=</span> searchController.searchBar.text</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        viewModel.search(with: query) &#123; users <span class="keyword">in</span></span><br><span class="line">            resultsViewController.update(users: users)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-完整交互流程（以-Combine-为例）"><a href="#3-完整交互流程（以-Combine-为例）" class="headerlink" title="3. 完整交互流程（以 Combine 为例）"></a>3. 完整交互流程（以 Combine 为例）</h3><h3 id="4-UIKit-MVVM-的优势与挑战"><a href="#4-UIKit-MVVM-的优势与挑战" class="headerlink" title="4. UIKit MVVM 的优势与挑战"></a>4. UIKit MVVM 的优势与挑战</h3><p><strong>优势：</strong></p><p><img src="/Users/youhan152/Desktop/Hexoblog/blog-demo/source/Hexoblog_imagin/%E5%AE%8C%E6%95%B4%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B.png" alt="完整交互流程"></p><ul><li><strong>极高的可测试性</strong>：ViewModel 不导入 <code>UIKit</code>，可轻松进行单元测试。</li><li><strong>更清晰的代码结构</strong>：将庞大的 <code>UIViewController</code>中的逻辑剥离出来，使其不再成为 “Massive View Controller”。</li><li><strong>更好的复用性</strong>：一个 ViewModel 可以被多个 ViewController 使用（例如 iPhone 和 iPad 的不同布局）。</li></ul><p><strong>挑战：</strong></p><ul><li><strong>需要手动绑定</strong>：需要借助 Combine、RxSwift 或闭包等方式实现绑定，有一定学习成本。</li><li><strong>入门门槛稍高</strong>：相对于传统的 MVC，需要更好地理解响应式编程概念。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在 UIKit 中实践 MVVM 是提升代码质量的重要手段。<strong>Combine 框架</strong>是目前最优雅和现代的实现方式，它极大地简化了绑定过程。通过这种模式，你可以构建出更易于测试、维护和扩展的 UIKit 应用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2.Markdown中Front-matter主要作用</title>
      <link href="/2025/09/23/2-Markdown%E4%B8%ADFront-matter%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8/"/>
      <url>/2025/09/23/2-Markdown%E4%B8%ADFront-matter%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h1><p>Front-matter 是 Markdown 文件开头的一块特殊区域，用于<strong>定义该文档的元数据（metadata）</strong>。它通常采用 YAML 格式，被包裹在三道短横线 <code>---</code>之间。</p><h3 id="✨-主要作用"><a href="#✨-主要作用" class="headerlink" title="✨ 主要作用"></a>✨ 主要作用</h3><p>Front-matter 的主要作用是<strong>为 Markdown 文档添加结构化信息</strong>，这些信息可供静态网站生成器（如 Hexo、Jekyll、VitePress、Docusaurus 等）或其它处理 Markdown 的工具读取和使用，以实现：</p><ul><li><strong>SEO优化</strong>：提供标题、描述、标签等，利于搜索引擎收录。</li><li><strong>内容管理</strong>：用于分类、排序、关联作者、控制展示等。</li><li><strong>定制呈现</strong>：控制页面布局、显示或隐藏特定元素。</li></ul><h3 id="📝-基本语法"><a href="#📝-基本语法" class="headerlink" title="📝 基本语法"></a>📝 基本语法</h3><p>Front-matter 放置在 Markdown 文件的最顶部。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 你的文章标题</span><br><span class="line">date: 2024-03-15</span><br><span class="line">author: 作者名</span><br><span class="line">tags: [标签1, 标签2]</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="🗂️-常见配置项"><a href="#🗂️-常见配置项" class="headerlink" title="🗂️ 常见配置项"></a>🗂️ 常见配置项</h3><p>Front-matter 支持许多配置项，下表列出了一些常见的字段及其用途：</p><table><thead><tr><th>配置项 (Field)</th><th>类型 (Type)</th><th>说明 (Description)</th></tr></thead><tbody><tr><td><strong><code>title</code></strong></td><td>string</td><td><strong>文章标题</strong>，显示在页面头部与浏览列表中。</td></tr><tr><td><strong><code>date</code></strong></td><td>string</td><td><strong>文章发布日期</strong>，格式通常为 <code>YYYY-MM-DD</code>。</td></tr><tr><td><strong><code>author</code></strong></td><td>string</td><td><strong>文章作者</strong>。</td></tr><tr><td><strong><code>tags</code></strong></td><td>array</td><td><strong>文章标签</strong>，用于分类文章或支持标签页。通常写成数组形式，如 <code>[tag1, tag2]</code>。</td></tr><tr><td><strong><code>categories</code></strong></td><td>array</td><td><strong>文章分类</strong>。</td></tr><tr><td><strong><code>description</code></strong></td><td>string</td><td><strong>文章摘要或描述</strong>，常用于SEO和文章列表的简介显示。</td></tr><tr><td><strong><code>layout</code></strong></td><td>string</td><td><strong>指定布局模板</strong>（如 <code>post</code>, <code>page</code>）。</td></tr><tr><td><strong><code>permalink</code></strong></td><td>string</td><td><strong>自定义文章的超链接地址</strong>。</td></tr><tr><td><strong><code>published</code></strong></td><td>boolean</td><td><strong>是否发布</strong>，<code>false</code>则文章不会被渲染。</td></tr><tr><td><strong><code>image</code></strong></td><td>string</td><td><strong>文章封面图或特色图像的URL</strong>。</td></tr><tr><td><strong><code>slug</code></strong></td><td>string</td><td><strong>文章的友好URL名称</strong>，用于生成最终访问路径。</td></tr><tr><td><strong><code>hide_table_of_contents</code></strong></td><td>boolean</td><td><strong>是否隐藏文章右侧的目录</strong>。<code>true</code>为隐藏。</td></tr><tr><td><strong><code>sidebar_position</code></strong></td><td>number</td><td><strong>控制文章在侧边栏中的排序位置</strong>，数字越小越靠前。</td></tr></tbody></table><h3 id="⚠️-注意事项"><a href="#⚠️-注意事项" class="headerlink" title="⚠️ 注意事项"></a>⚠️ 注意事项</h3><p>使用 Front-matter 时，需要注意以下几点：</p><ul><li><strong>位置必须正确</strong>：它<strong>必须</strong>位于 Markdown 文件的<strong>最开头</strong>，之前不能有任何内容（包括空格）。</li><li><strong>格式必须规范</strong>：确保使用正确的 YAML 语法。键值对的冒号后通常要有一个空格，数组元素按规范书写。</li><li><strong>解析器支持</strong>：Front-matter 本身不会被渲染到最终的 HTML 页面中，其功能需要静态网站生成器或特定插件（如 <code>markdown-it-front-matter</code>）的支持来解析和使用。</li></ul><h3 id="💡-使用场景"><a href="#💡-使用场景" class="headerlink" title="💡 使用场景"></a>💡 使用场景</h3><p>Front-matter 非常适合以下场景：</p><ul><li><strong>静态博客</strong>：Hexo、Jekyll、Hugo 等广泛使用 Front-matter 来管理文章的所有元信息。</li><li><strong>文档站点</strong>：VitePress、Docusaurus 等用其来设置页面标题、描述、侧边栏排序等。</li><li><strong>内容管理系统 (CMS)</strong>：一些 CMS 会利用 Front-matter 来存储内容的相关配置和数据。</li></ul><p>Front-matter 很好地补充了 Markdown 在元数据管理方面的不足，通过简单的 YAML 语法，就能让文档携带丰富的结构化信息。</p><p>希望这些信息能帮助你更好地理解和使用 Front-matter。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Front-matter </tag>
            
            <tag> 知识讲解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.Hello World</title>
      <link href="/2025/09/23/1-hello-world/"/>
      <url>/2025/09/23/1-hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
